p.7 상속 관계로 클래스의 간결화 사례

김준희 Q: 각각 다른 클래스에 공통된 기능이 있어 상속하여 나눌 수 있지 않을까?
안정빈 A: 말하기, 먹기, 걷기, 잠자기 4개의 기능이 클래스에 공통되어 있어 이 기능들을 가진 클래스를 만들어 상속받으면 된다.

안정빈 Q: 나머지 기능들은 어떻게 하면 좋을까?
김준희 A: 공부하기 기능이 중복된 클래스들중 일하기 기능을 가진 클래스가 공부하기 기능을 가진 클래스를 상속받게 하고
          연구하기 기능이 중복된 클래스들중 가르치기 기능을 가진 클래스가 연구하기 기능을 가진 클래스를 상속받게 만들면 된다.


업 캐스팅에 대해 이해하는 과정

업 캐스팅이란? -> 파생 클래스 포인터가 기본 클래스 포인터에 치환되는 것이다.
                 
ex)
   ColorPoint Cp;
   ColorPoint *pDer;
   Point *pBase = &cp; // 업 캐스팅


다운 캐스팅에 대해 이해하는 과정

다운 캐스팅이란? -> 기본 클래스의 포인터가 파생 클래스의 포인터에 치환되는 것이다.

ex)
   ColorPoint Cp;
   ColorPoint *pDer;
   Point *pBase = &cp;

   pDer = (ColorPoint *)pBase; // 다운캐스팅
              

접근 지정자를 이해하는 과정

안정빈 Q: 접근 지정자의 종류는 무엇이 있는가?
김준희 A: private, public, protected 멤버들이 있다.

김준희 Q: 이들의 차이점은 무엇인가?
안정빈 A: private 멤버는 선언된 클래스 내에서만 접근이 가능하다.
          public 멤버는 선언된 클래스나 외부 어떤 클래스,모든 외부 함수에 접근이 가능하다.
          protected 멤버는 선언된 클래스 에서만 접근이 가능하다.

안정빈 Q: 파생 클래스에서도 적용이 되는가?
김준희 A: private 멤버는 파생클래스 에서도 기본 클래스의 private멤버에 직접 접근이 불가하다.
         public 멤버는 기본 클래스의 public 멤버에 접근이 가능하다.
         protected 멤버는 파생 클래스에서만 접근이 가능하다.


기본 클래스, 파생 클래스 의 생성자 호출을 이해하는 과정

기본 클래스에 기본 생성자가 있는 경우
-> 컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 호출하게 한다.

기본 클래스에 기본 생성자가 없는 경우 
-> 컴파일러가 짝을 찾을 수 없으므로 컴파일 오류가 발생한다.

파생 클래스의 매개 변수를 가진 생성자가 기본 클래스에 있는 경우
-> 컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 호출하게 한다.


예제 8-2 오류 이유
1번 코드의 경우 Point 클래스의 x,y가 protected이므로 ColorPoint에서 접근 가능 따라서 오류 x
2번 코드 또한 Point 클래스가 public으로 지정된 set함수에 접근하므로 오류 x
3,4,5,6 번 코드의 경우 protected로 지정된 x와 y를 접근하기 때문에 오류 발생
7번 코드는 ColorPoint의 equals 함수가 public이므로 접근 가능 따라서 오류 x


상속 지정을 이해하는 과정

김준희 Q: 상속을 선언할 때에도 접근 지정자를 지정하는데 각각의 멤버들은 기본 클래스의 멤버의 접근 속성을 어떻게 계승하는가?
안정빈 A:  public 멤버는 기본 클래스의 protected, public 멤버 속성을 그대로 계승한다.
           private 멤버는 기본 클래스의 protected, public 멤버를 private으로 계승한다.
           protected 멤버는 기본 클래스의 protected, public 멤버를 protected로 계승한다.


다중 상속이란? -> 하나의 파생 클래스가 여러 클래스들 동시에 상속받는 것을 의미한다.
예제 8-7의 경우 클래스 Calculator가 Adder 클래스와 Subtractor 클래스를 동시에 상속 선언하였으므로 상속 받은 클래스들의 함수 호출이 가능하다.

다중 상속의 문제점: 멤버가 객체에 중복으로 삽입될 경우 컴파일 오류 발생한다.
이에 대한 해결방안: 다중 상속의 모호성을 해결하기 위해 기본 클래스를 가상 상속 받게한다.


수업중 어려웟던 내용
예제 8-6의 경우 6번 코드에서 클래스 GrandDerived 클래스 Derived를 'private'로 상속하면서
setB(x); 코드가 private로 변경되면서 호출되어 컴파일 오류가 발생할거라 생각하여 이에 대해 짝과 토의를 다시 진행함
-> 이를 통해 상속에 대해 다시 한번 이해하면서 GrandDerived의 protected로 지정된 setB(x)를 호출할 경우
   private로 변경되어 호출된는 것이 아닌 protected 멤버 그대로 호출됨을 알게됨.

